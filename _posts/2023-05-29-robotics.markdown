---
layout: post
title:  "Robotics"
date:   2023-05-29 21:26:14 -0400
categories: jekyll update
---

# Interesting Robotics Projects

## Table of Conents
1. [IEEE SoutheastCon Robotics Competition](#item-1)
2. [Scara Robot Simulation](#item-2)
    1. [Python GUI for Manual Control](#sub2-item-1)
    2. [Clicked Point Path Generation](#sub2-item-2)
    3. [Before Clicked Point](#sub2-item-3)
    4. [After Clicked Point](#sub2-item-4)

<a id="item-1"></a>
## IEEE SoutheastCon Robotics Competition
Talk about developing HAL
Include picture from competition expo and such

![test](/docs/assets/img/test.png)

***

<a id="item-2"></a>
## Scara Robot Simulation
#### Purpose of this project was to apply the principles of forward and inverse kinematics to a 4 link Scara Robot. The simulation was implemented using Robotic Operating System (ROS) and interfaced in python using the PyQT5 library for the GUI and  RVIZ/Gazebo for the 3D simulation. The simulation allows the user to manually control the robot using the GUI or have the robot follow a path generated by the user clicking on the RVIZ display. The forward kinematics were implemented using the Denavit-Hartenberg convention and the inverse kinematics were implemented using the geometric method. The simulation was developed in a Linux environment and the ROS package I created that includes all the  code can be cloned from this [repository] [robotics repo] in the projects/scara directory on my GitHub.

<a id="sub2-item-1"></a>
### Python GUI for Manual Control
The followng GUI is prompted after running the custom launch file created for this part of the project:

```$ roslaunch robotics scara_gui.launch```

<img src= "https://suqjuan.github.io/docs/assets/img/scaraGUI.png"/>

The GUI enables the user to manually control each of the links individually using the sliders. The sliders are connected to ROS topics that publish the slider values to the ROS environment. The ROS nodes that are subscribed to these topics are the nodes that control the joint angles of the robot which are specified in the custom URDF file created for the robot.

<a id="sub2-item-2"></a>
### Clicked Point Path Generation
While the GUI I created is a great way to test the understanding of robotics principles, I wanted to take it a step further and implement an algorith which would not require the user to manually input values for each of the joints. Instead something more practical would be to implement an algorithm that enforces the inverse kinematics of the robot and calculates and updates joint parameters automatically. So this is exactly what I did. I started with a python program where a user can input a desired x,y,z cooridinate relative to the base frame in the program, but soon realized that this is not practical. Instead I took advantage of the ability to click on points in RVIZ, and publish the coordinates through a ROS message to my Python program instead of having to edit, run, edit, run each time I wanted to visualize a different end effector position. Thus, implemented the support for clicked points allowed for a continuous visual and form of validation of the inverse kinematics for the robot.

The followng program will run after executing the following commands:

First the Python program that handles all calculation and published updated joint parameters must be run using the following command:

``` $ rosrun robotics scara_FK.py```

Then the the custom launch file must be ran using:

``` $ roslaunch robotics scara.launch```

<a id="sub2-item-3"></a>
### Before Clicked Point 
<img src= "https://suqjuan.github.io/docs/assets/img/scaraBefore.png" />

The image above represents the initial position of the robot; the end-effector is the bottom tip of of the red link on the left.

<a id="sub2-item-4"></a>
### After Clicked Point
<img src= "https://suqjuan.github.io/docs/assets/img/scaraAfter.png"/>

Clicked points in RVIZ represented by pink spheres. In the above visualy we can see that after clicking on this position represented my the pink sphere, the inverse kinematics were executed properly since the end-effector was able to update it joint parameters appropriately to move the end-effector to the desired location.

***

[robotics repo]:https://github.com/Suqjuan/robotics

